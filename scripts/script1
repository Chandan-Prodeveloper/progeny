-- =============================================
-- COMPLETE SUPABASE DATABASE FIX
-- This script will fix all issues with user scanning functionality
-- =============================================

BEGIN;

-- =============================================
-- 1. CLEAN UP EXISTING POLICIES AND FUNCTIONS
-- =============================================



-- =============================================
-- 2. RECREATE CLEAN TABLE STRUCTURE
-- =============================================

-- Ensure profiles table has correct structure
CREATE TABLE IF NOT EXISTS public.profiles (
  id uuid primary key references auth.users(id) on delete cascade,
  full_name text,
  email text unique not null,
  phone_number text,
  is_admin boolean default false,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Ensure scans table has correct structure
CREATE TABLE IF NOT EXISTS public.scans (
  id uuid primary key default gen_random_uuid(),
  user_id uuid not null references auth.users(id) on delete cascade,
  image_url text not null,
  disease_name text,
  confidence_score decimal(3,2) check (confidence_score >= 0 and confidence_score <= 1),
  remedies text[] default '{}',
  status text not null default 'pending' check (status in ('pending', 'processing', 'completed', 'failed')),
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Ensure daily_usage table has correct structure
CREATE TABLE IF NOT EXISTS public.daily_usage (
  id uuid primary key default gen_random_uuid(),
  user_id uuid not null references auth.users(id) on delete cascade,
  date date not null default current_date,
  scans_used integer default 0,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null,
  unique(user_id, date)
);

-- Ensure subscriptions table exists
CREATE TABLE IF NOT EXISTS public.subscriptions (
  id uuid primary key default gen_random_uuid(),
  user_id uuid not null references auth.users(id) on delete cascade,
  stripe_subscription_id text unique,
  stripe_customer_id text,
  status text not null default 'inactive',
  scans_remaining integer default 0,
  expires_at timestamp with time zone,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Enable RLS on all tables
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.scans ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.daily_usage ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.subscriptions ENABLE ROW LEVEL SECURITY;

-- =============================================
-- 3. CREATE CLEAN RLS POLICIES
-- =============================================

-- Profiles policies
CREATE POLICY "profiles_own_access" ON profiles
  FOR ALL USING (auth.uid() = id);

CREATE POLICY "profiles_admin_access" ON profiles
  FOR SELECT USING (
    EXISTS (
      SELECT 1 FROM profiles p2 
      WHERE p2.id = auth.uid() AND p2.is_admin = true
    )
  );

-- Scans policies
CREATE POLICY "scans_own_access" ON scans
  FOR ALL USING (auth.uid() = user_id);

CREATE POLICY "scans_admin_access" ON scans
  FOR SELECT USING (
    EXISTS (
      SELECT 1 FROM profiles 
      WHERE id = auth.uid() AND is_admin = true
    )
  );

-- Daily usage policies
CREATE POLICY "daily_usage_own_access" ON daily_usage
  FOR ALL USING (auth.uid() = user_id);

CREATE POLICY "daily_usage_admin_access" ON daily_usage
  FOR SELECT USING (
    EXISTS (
      SELECT 1 FROM profiles 
      WHERE id = auth.uid() AND is_admin = true
    )
  );

-- Subscriptions policies
CREATE POLICY "subscriptions_own_access" ON subscriptions
  FOR ALL USING (auth.uid() = user_id);

CREATE POLICY "subscriptions_admin_access" ON subscriptions
  FOR SELECT USING (
    EXISTS (
      SELECT 1 FROM profiles 
      WHERE id = auth.uid() AND is_admin = true
    )
  );

-- =============================================
-- 4. CREATE PROPER FUNCTIONS
-- =============================================

-- Function to handle new user registration
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  admin_emails text[] := ARRAY[
    'ramrakhyanidarshan@gmail.com',
    'arorachandan2004@gmail.com',
    '22cs93@ecajmer.ac.in',
    'parthdadhich15augast@gmail.com'
  ];
BEGIN
  -- Insert profile
  INSERT INTO public.profiles (id, full_name, email, phone_number, is_admin)
  VALUES (
    NEW.id,
    COALESCE(NEW.raw_user_meta_data ->> 'full_name', ''),
    NEW.email,
    COALESCE(NEW.raw_user_meta_data ->> 'phone_number', ''),
    NEW.email = ANY(admin_emails)
  )
  ON CONFLICT (id) DO UPDATE SET
    email = EXCLUDED.email,
    is_admin = EXCLUDED.is_admin,
    updated_at = NOW();

  -- Create initial daily usage record
  INSERT INTO public.daily_usage (user_id, date, scans_used)
  VALUES (NEW.id, CURRENT_DATE, 0)
  ON CONFLICT (user_id, date) DO NOTHING;

  RETURN NEW;
END;
$$;

-- Recreate trigger
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW
  EXECUTE FUNCTION public.handle_new_user();

-- Function to check if user can scan
CREATE OR REPLACE FUNCTION public.can_user_scan(user_uuid uuid)
RETURNS boolean
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    user_is_admin boolean := false;
    user_has_active_subscription boolean := false;
    daily_scans_used integer := 0;
    subscription_scans integer := 0;
    max_daily_scans integer := 5;
BEGIN
    -- Ensure user profile exists
    INSERT INTO public.profiles (id, email, full_name, is_admin, created_at, updated_at)
    SELECT 
        user_uuid,
        COALESCE(u.email, 'unknown@example.com'),
        COALESCE(u.raw_user_meta_data->>'full_name', 'User'),
        u.email = ANY(ARRAY[
            'ramrakhyanidarshan@gmail.com',
            'arorachandan2004@gmail.com',
            '22cs93@ecajmer.ac.in',
            'parthdadhich15augast@gmail.com'
        ]),
        NOW(),
        NOW()
    FROM auth.users u
    WHERE u.id = user_uuid
    ON CONFLICT (id) DO NOTHING;
    
    -- Get user admin status
    SELECT COALESCE(is_admin, false) INTO user_is_admin
    FROM public.profiles
    WHERE id = user_uuid;
    
    -- Admins have unlimited scans
    IF user_is_admin THEN
        RETURN true;
    END IF;
    
    -- Check for active subscription with remaining scans
    SELECT 
        EXISTS(
            SELECT 1 FROM public.subscriptions 
            WHERE user_id = user_uuid 
            AND status = 'active' 
            AND (expires_at IS NULL OR expires_at > NOW())
            AND scans_remaining > 0
        ),
        COALESCE(
            (SELECT scans_remaining FROM public.subscriptions 
             WHERE user_id = user_uuid 
             AND status = 'active' 
             AND (expires_at IS NULL OR expires_at > NOW())
             ORDER BY created_at DESC 
             LIMIT 1), 
            0
        )
    INTO user_has_active_subscription, subscription_scans;
    
    -- If user has subscription scans, allow scan
    IF user_has_active_subscription AND subscription_scans > 0 THEN
        RETURN true;
    END IF;
    
    -- Check daily usage for free users
    SELECT COALESCE(scans_used, 0) INTO daily_scans_used
    FROM public.daily_usage
    WHERE user_id = user_uuid AND date = CURRENT_DATE;
    
    -- Allow scan if under daily limit
    RETURN daily_scans_used < max_daily_scans;
END;
$$;

-- Function to increment scan usage (FIXED)
CREATE OR REPLACE FUNCTION public.increment_scan_usage(user_uuid uuid)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    user_is_admin boolean := false;
    subscription_id uuid;
    subscription_scans integer := 0;
BEGIN
    -- Get user admin status
    SELECT COALESCE(is_admin, false) INTO user_is_admin
    FROM public.profiles
    WHERE id = user_uuid;
    
    -- Don't track usage for admin users
    IF user_is_admin THEN
        RETURN;
    END IF;
    
    -- Get the most recent active subscription with remaining scans
    SELECT s.id, COALESCE(s.scans_remaining, 0)
    INTO subscription_id, subscription_scans
    FROM public.subscriptions s
    WHERE s.user_id = user_uuid 
    AND s.status = 'active' 
    AND (s.expires_at IS NULL OR s.expires_at > NOW())
    AND s.scans_remaining > 0
    ORDER BY s.created_at DESC 
    LIMIT 1;
    
    -- If user has subscription scans, deduct from subscription
    IF subscription_id IS NOT NULL AND subscription_scans > 0 THEN
        UPDATE public.subscriptions
        SET scans_remaining = scans_remaining - 1,
            updated_at = NOW()
        WHERE id = subscription_id;
    ELSE
        -- Otherwise, increment daily usage
        INSERT INTO public.daily_usage (user_id, date, scans_used, created_at, updated_at)
        VALUES (user_uuid, CURRENT_DATE, 1, NOW(), NOW())
        ON CONFLICT (user_id, date)
        DO UPDATE SET 
            scans_used = daily_usage.scans_used + 1,
            updated_at = NOW();
    END IF;
END;
$$;

-- Function to get user scan status
CREATE OR REPLACE FUNCTION public.get_user_scan_status(user_uuid uuid)
RETURNS TABLE(
    can_scan boolean,
    is_admin boolean,
    daily_scans_used integer,
    daily_scans_limit integer,
    subscription_scans integer,
    has_active_subscription boolean
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
    RETURN QUERY
    SELECT 
        public.can_user_scan(user_uuid) as can_scan,
        COALESCE(p.is_admin, false) as is_admin,
        COALESCE(du.scans_used, 0) as daily_scans_used,
        5 as daily_scans_limit,
        COALESCE(s.scans_remaining, 0) as subscription_scans,
        COALESCE(
            (s.status = 'active' AND (s.expires_at IS NULL OR s.expires_at > NOW())), 
            false
        ) as has_active_subscription
    FROM public.profiles p
    LEFT JOIN public.daily_usage du ON (du.user_id = p.id AND du.date = CURRENT_DATE)
    LEFT JOIN public.subscriptions s ON (s.user_id = p.id AND s.status = 'active' AND (s.expires_at IS NULL OR s.expires_at > NOW()))
    WHERE p.id = user_uuid;
END;
$$;

-- =============================================
-- 5. CREATE UPDATED_AT TRIGGERS
-- =============================================

-- Updated at trigger function
CREATE OR REPLACE FUNCTION public.handle_updated_at()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$;

-- Create triggers
DROP TRIGGER IF EXISTS profiles_updated_at ON profiles;
CREATE TRIGGER profiles_updated_at
    BEFORE UPDATE ON public.profiles
    FOR EACH ROW EXECUTE FUNCTION public.handle_updated_at();

DROP TRIGGER IF EXISTS scans_updated_at ON scans;
CREATE TRIGGER scans_updated_at
    BEFORE UPDATE ON public.scans
    FOR EACH ROW EXECUTE FUNCTION public.handle_updated_at();

DROP TRIGGER IF EXISTS daily_usage_updated_at ON daily_usage;
CREATE TRIGGER daily_usage_updated_at
    BEFORE UPDATE ON public.daily_usage
    FOR EACH ROW EXECUTE FUNCTION public.handle_updated_at();

DROP TRIGGER IF EXISTS subscriptions_updated_at ON subscriptions;
CREATE TRIGGER subscriptions_updated_at
    BEFORE UPDATE ON public.subscriptions
    FOR EACH ROW EXECUTE FUNCTION public.handle_updated_at();

-- =============================================
-- 6. SETUP ADMIN USERS
-- =============================================

-- Set admin users (update existing profiles)
UPDATE public.profiles 
SET is_admin = true, updated_at = NOW()
WHERE email IN (
    'ramrakhyanidarshan@gmail.com',
    'arorachandan2004@gmail.com',
    '22cs93@ecajmer.ac.in',
    'parthdadhich15augast@gmail.com'
);

-- Create profiles for admin users if they exist in auth but not in profiles
INSERT INTO public.profiles (id, email, full_name, is_admin, created_at, updated_at)
SELECT 
    u.id,
    u.email,
    COALESCE(u.raw_user_meta_data->>'full_name', 
        CASE u.email
            WHEN 'ramrakhyanidarshan@gmail.com' THEN 'Darshan Ramrakhyani'
            WHEN 'arorachandan2004@gmail.com' THEN 'Chandan Arora'
            WHEN '22cs93@ecajmer.ac.in' THEN 'Rachit Tripathi'
            WHEN 'parthdadhich15augast@gmail.com' THEN 'Parth Tripathi'
            ELSE 'Admin User'
        END
    ),
    true,
    NOW(),
    NOW()
FROM auth.users u
WHERE u.email IN (
    'ramrakhyanidarshan@gmail.com',
    'arorachandan2004@gmail.com',
    '22cs93@ecajmer.ac.in',
    'parthdadhich15augast@gmail.com'
)
ON CONFLICT (id) DO UPDATE SET
    is_admin = true,
    updated_at = NOW();

-- =============================================
-- 7. CREATE INDEXES FOR PERFORMANCE
-- =============================================

CREATE INDEX IF NOT EXISTS profiles_email_idx ON public.profiles(email);
CREATE INDEX IF NOT EXISTS profiles_is_admin_idx ON public.profiles(is_admin);
CREATE INDEX IF NOT EXISTS scans_user_id_idx ON public.scans(user_id);
CREATE INDEX IF NOT EXISTS scans_created_at_idx ON public.scans(created_at DESC);
CREATE INDEX IF NOT EXISTS scans_status_idx ON public.scans(status);
CREATE INDEX IF NOT EXISTS daily_usage_user_date_idx ON public.daily_usage(user_id, date);
CREATE INDEX IF NOT EXISTS subscriptions_user_status_idx ON public.subscriptions(user_id, status);

COMMIT;

-- =============================================
-- 8. VERIFICATION QUERIES
-- =============================================

-- Check admin users
SELECT 
    p.email,
    p.full_name,
    p.is_admin,
    u.id
FROM public.profiles p
JOIN auth.users u ON p.id = u.id
WHERE p.is_admin = true
ORDER BY p.email;

-- Test scan functionality for a regular user (replace with actual user ID)
-- SELECT * FROM public.get_user_scan_status('USER_UUID_HERE'::uuid);